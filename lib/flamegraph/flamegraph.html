<!DOCTYPE html>
<html>
<head>
/**INCLUDES**/
<script
  src="https://code.jquery.com/color/jquery.color-2.1.2.min.js"
  integrity="sha256-H28SdxWrZ387Ldn0qogCzFiUDDxfPiNIyJX7BECQkDE="
  crossorigin="anonymous"></script>


<meta charset=utf-8 />

<title>Flame Graph of Page</title>
<style>
  .info {min-height: 50px; margin: 10px; }
  .legend div {
    display: block;
    float: left;
    width: 150px;
    margin: 0 8px 8px;
    padding: 4px;
    height: 50px;
  }
  .code {
    font-family: Consolas, Menlo, Monaco, "Lucida Console", "Liberation Mono", "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Courier New", monospace;
  }
  #frameinfo table .sample-info {
    width: 200px;
    color: #333;
    font-size: 12px;
  }
  #frameinfo table {
    border-collapse: collapse;
  }
  #frameinfo table tr {
    border-bottom: 1px solid #eee;
    margin-top: 5px;
  }
  #frameinfo td {
    padding: 5px;
  }
  #frameinfo-wrapper {
    position: fixed;
    z-index: 1;
    opacity: 0.7;
    background-color: black;
    width: 100%;
    height: 100%;
    top: 0;
    left: 0;
    display: none;
  }
  #frameinfo {
    position: fixed;
    padding: 10px;
    z-index: 2;
    opacity: 1.0;
    top: 0;
    margin-top: 50px;
    margin-left: 40px;
    width: 80%;
    height: 80%;
    background-color: white;
    border: 2px solid #666;
    display: none;
    overflow: auto;
  }
</style>
</head>
<body>
  <div class="graph"></div>
  <div class="info code"></div>
  <div class="draw_options">
    <form class="form-inline">
      <div class="form-group">
      <div class="form-check form-check-inline">
        <label class="form-check-label">
          <input class="form-check-input" type="radio" name="by_method" id="inlineRadio1" value="true"> By Method
        </label>
      </div>
      <div class="form-check form-check-inline">
        <label class="form-check-label">
          <input class="form-check-input" type="radio" name="by_method" id="inlineRadio2" value="false"> By Gem
        </label>
      </div>
      </div>

      <div class="form-group">
        <label for="display_width">Width</label>
        <input type="text" id="display_width" class="form-control mx-sm-3" value="1" />
      </div>
      <div class="form-group">
        <label for="filter_string">Filters</label>
        <input type="text" id="filter_string" class="form-control mx-sm-3" value="app/" />
      </div>
      <button data-action="update">update</button>
      <button data-action="reset_zoom">reset zoom</button>
    </form>
    <br/>
  </div>
    <br/>
  <div class="legend"></div>
  <div id="frameinfo-wrapper"></div>
  <div id="frameinfo">
    <h3>Frame Info</h3>
    <table>
    </table>
  </div>
  <script>

var data = /**DATA**/;
var maxX = 0;
var maxY = 0;
var guessGem = function(frame)
{
  var split = frame.split('/gems/');
  if(split.length == 1) {
    split = frame.split('/app/');
    if(split.length == 1) {
      split = frame.split('/lib/');
    }

    split = split[Math.max(split.length-2,0)].split('/');
    return split[split.length-1].split(':')[0];
  }
  else
  {
    return split[split.length -1].split('/')[0];
  }
}

var guessMethod = function(frame) {
  var split = frame.split('`');
  if(split.length == 2) {
    var fullMethod = split[1].split("'")[0];
    split = fullMethod.split("#");
    if(split.length == 2) {
      return split[1];
    }
    return split[0];
  }
  return '?';
}

var guessFile = function(frame) {
  var split = frame.split(".rb:");
  if(split.length == 2) {
    split = split[0].split('/');
    return split[split.length - 1];
  }
  return "";
}

$.each(data, function(){
   maxX = Math.max(maxX, this.x + this.width);
   maxY = Math.max(maxY, this.y);
   this.methodName = guessMethod(this.frame);
   this.gemName = guessGem(this.frame);
   this.fileName = guessFile(this.frame);
   this.opacityFactor = 1;
});

oMaxX = maxX;
oMaxY = maxY;

var width = $(window).width();
var height = $(window).height() / 1.2;

$('.graph').width(width).height(height);

var xScale = d3.scale.linear()
  .domain([0, maxX])
    .range([0, width]);

var yScale = d3.scale.linear()
    .domain([0, maxY])
    .range([0,height]);

var svg = d3.select(".graph")
                    .append("svg")
                    .attr("width", "100%")
                    .attr("height", "100%")
                    .attr("pointer-events", "all")
                    .append('svg:g')
                    .append('svg:g');

var color = function() {
  var r = parseInt(205 + Math.random() * 50);
  var g = parseInt(Math.random() * 230);
  var b = parseInt(Math.random() * 55);
  return "rgb(" + r + "," + g + "," + b + ")";
}
var info = {};

var samplePercent = function(samples, exclusive){
  var info = " (" + samples +
    " sample" + (samples == 1 ? "" : "s") + " - " +
    ((samples / oMaxX) * 100).toFixed(2) + "%) ";
  if (exclusive) {
    info += " (" + exclusive +
      " exclusive - " +
    ((exclusive / oMaxX) * 100).toFixed(2) + "%) ";
  }
  return info;
}

var mouseover =  function(d) {
  var i = info[d.frame];
  $('.info').text( d.frame + " " + samplePercent(i.samples.size, d.topFrame ? d.topFrame.exclusiveCount : 0));
  d3.selectAll(i.nodes)
     .attr('opacity',0.5);
};

var mouseout = function(d) {
  var i = info[d.frame];
  $('.info').text("");
  d3.selectAll(i.nodes)
    .attr('opacity', function(f) { return f.opacityFactor });
};

// highlight the nodes of a gem
var gemSelect = function(e) {
  var name = e.data.name;
  d3.selectAll(getGemNodes(name)).attr('opacity',0.5);
  return false;
};

// remove highlighting of the nodes of a gem
var gemDeSelect = function(e) {
  var name = e.data.name;
  d3.selectAll(getGemNodes(name)).attr('opacity', function(d) { return d.opacityFactor });
  return false;
};

// given the name of a gem, return all of its nodes
var getGemNodes = function(gem_name) {
  var frames = gemStats[gem_name].frames;
  var nodes = [];
  $.each(frames, function(i,f) {
  var i = info[f];
  nodes = nodes.concat(i.nodes);
  });
  return nodes;
};

var backtrace = function(frame){
  for(var i=0; i<data.length; i++){
    if(frame === data[i]){ break; }
  }

  frames = [frame];
  var depth = frame.y;

  while(i > 0){
    if(depth == -1) break;

    if(data[i].y === depth-1) {
      frames.push(data[i]);
      depth--;
    }

    i--;
  }

  return frames;
}

$('#frameinfo-wrapper').click(function(d){
    $(this).hide();
    $('#frameinfo').hide();
});

$(window).keyup(function(e) {
  if (e.keyCode==27)
    $('#frameinfo-wrapper,#frameinfo').hide();
});

var reset_element = function(e) {
  if (!e.filtered_out) {
    e.y = e.filteredY || e.oY;
    e.x = e.oX;
    e.width = e.oWidth;
    e.opacityFactor = 1;
  }
}

var reset_data = function() {
  for(var i = 0; i < data.length; i++) {
    var d = data[i];

    reset_element(d);
  }
}

var reset_zoom = function() {
  current_zoom = null;
  reset_data();
  process_data(data);
  draw_data(data);
}

var zoom = function(d) {
  current_zoom = d;

  // reset_data();
  for(var i = 0; i < data.length; i++) {
    var f = data[i];

    if (f.filtered_out) {
      continue;
    }

    var visible_parent = function(d) {
      var current_parent = d.parent;
      while(current_parent && current_parent.y <= 0) {
        current_parent = current_parent.parent;
      }

      return current_parent;
    }

    vp = visible_parent(d);

    reset_element(f);
    if (f === d) {
      f.opacityFactor = 1;
    } else if (
        f.oY > d.oY &&
        f.oX >= d.oX && f.oX + f.oWidth <= d.oX + d.oWidth
        ){
    } else if (f === vp) {
      f.width = d.oWidth;
      f.x = d.oX;
      f.opacityFactor = 0.5;
    } else if (
        f.oY < d.oY &&
        f.oX <= d.oX
        ){
      f.width = 0;
      f.x = 1;
      f.y = 1;
    } else {
      f.width = 0;
      f.x = 1;
      f.y = 1;
    }

    f.x = f.x - d.oX + 1;
  }


  process_data(data);
  draw_data(data);

  return false;
}

var backtrace_data = function(d){
  console.log(d);
  var trace = backtrace(d);

  var link = function(path, dest){
    return path.replace(/[^\/]+:\d+/, function(x){ return "<a target='_blank' href='"+ dest +"'>" + x + "</a>"})
  };

  var linkify = function(path){
    var split = path.split("/")[0].split("-");
    if(["actionview","activerecord","actionpack","railties","activesupport", "rails"].indexOf(split[0]) > -1) {
      var github = "https://github.com/rails/rails/blob/";
      var file = path.split(":")[0].split("/");
      if(split[0] === "rails") {
        file.shift();
      } else {
        file[0] = split[0];
      }

      github += (split[1].length < 6 ? "v" : "") + split[1] + "/";
      github += file.join("/");
      github += "#L" + parseInt(path.split(":")[1]);

      return link(path, github);
    }
    return path;
  }

  var simplify = function(frame){
    var split = frame.split('/gems/');
    if(split.length > 1){
      var path = linkify(split.pop());
      return "<span class='full-location'>" + split.join('/gems/') + "/</span>" + path;
    } else {
      return frame;
    }
  }

  var table = trace.map(function(f){
        var i = info[f.frame];
        return "<tr><td class='code'>" + simplify(f.frame) + "</td><td class='sample-info'>" +
                samplePercent(i.samples.size, f.topFrame ? f.topFrame.exclusiveCount : 0) + 
                "</td></tr>";
      }).join("\n");

  var table = $('#frameinfo table').html(table);
  var children = d.children.map(function(f){
        var i = info[f.frame];
        return "<tr><td class='code'>" + simplify(f.frame) + "</td><td class='sample-info'>" +
                samplePercent(i.samples.size, f.topFrame ? f.topFrame.exclusiveCount : 0) + 
                "</td></tr>";
      }).join("\n");
  table.append('<tr><td colspan="2"><h3>Calls</h3></td></tr>').append(children);
  table.find(".full-location").hide().after("<span class='expand'>&hellip; </span>");
  table.find(".expand").css({cursor: "pointer"}).click(function(){
      $(this).hide().parent().find(".full-location").show();
  });

  $('#frameinfo-wrapper').show();
  $('#frameinfo').show();
};

// http://stackoverflow.com/a/7419630
var rainbow = function(numOfSteps, step) {
    // This function generates vibrant, "evenly spaced" colours (i.e. no clustering). This is ideal for creating easily distiguishable vibrant markers in Google Maps and other apps.
    // Adam Cole, 2011-Sept-14
    // HSV to RBG adapted from: http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript
    var r, g, b;
    var h = step / numOfSteps;
    var i = ~~(h * 6);
    var f = h * 6 - i;
    var q = 1 - f;
    switch(i % 6){
        case 0: r = 1, g = f, b = 0; break;
        case 1: r = q, g = 1, b = 0; break;
        case 2: r = 0, g = 1, b = f; break;
        case 3: r = 0, g = q, b = 1; break;
        case 4: r = f, g = 0, b = 1; break;
        case 5: r = 1, g = 0, b = q; break;
    }
    var c = "#" + ("00" + (~ ~(r * 255)).toString(16)).slice(-2) + ("00" + (~ ~(g * 255)).toString(16)).slice(-2) + ("00" + (~ ~(b * 255)).toString(16)).slice(-2);
    return (c);
}

rainbow = function (total, step) {
  // 30 random hues with step of 12 degrees
  var hue = Math.floor(Math.random() * total) * 12;

  return $.Color({
    hue: hue,
    saturation: 0.9,
    lightness: 0.5,
    alpha: 1
  }).toHexString();
};

var by_method = true;

function analyze_data(data) {
  // assign some colors, analyze samples per gem
  gemStats = {}
  var topFrames = {}
  var lastFrame = {frame: 'd52e04d-df28-41ed-a215-b6ec840a8ea5', x: -1}

  $.each(data, function(){
    var group = by_method ? guessMethod(this.frame) : guessGem(this.frame);

    var stat = gemStats[group];

    if(!stat) {
      gemStats[group] = stat = {name: group, samples: new Set(), frames: []};
    }

    stat.frames.push(this.frame);
    for(var j=0; j < this.width; j++){
      stat.samples.add(this.x + j);
    }
    // This assumes the traversal is in order
    if (lastFrame.x != this.x) {
      var topFrame = topFrames[lastFrame.frame]
      if (!topFrame) {
        topFrames[lastFrame.frame] = topFrame = {exclusiveCount: 0}
      }
      topFrame.exclusiveCount += 1;
      lastFrame.topFrame = topFrame;
    }
    lastFrame = this;

  });

  var topFrame = topFrames[lastFrame.frame]
  if (!topFrame) {
    topFrames[lastFrame.frame] = topFrame = {exclusiveCount: 0}
  }
  topFrame.exclusiveCount += 1;
  lastFrame.topFrame = topFrame;

  var totalGems = 0;
  $.each(gemStats, function(k,stat){
    totalGems++;
  });


  gemsSorted = _(gemStats).pairs()
                            .sortBy(function(item){
                                return -item[1].samples.size;
                              })
                            .map(function(item){return item[1]})
                            .value();

  var currentIndex = 0;
  _.each(gemsSorted, function(stat){

    stat.color = rainbow(totalGems, currentIndex);

    for(var x=0; x < stat.frames.length; x++) {
      info[stat.frames[x]] = info[stat.frames[x]] || {nodes: [], samples: new Set(), color: stat.color};
      info[stat.frames[x]].color = stat.color;
    }

    currentIndex += 1;
  });

}

var set_relations = function(data) {
  for(var i=0; i < data.length; i++) {
    var d = data[i];
    var x = i;
    var depth = d.y;

    d.parent = null;

    while(x > 0){

      if(data[x].y === depth - 1) {
        d.parent = data[x];
        data[x].children = data[x].children || [];
        if ($.inArray(d, data[x].children) == -1) {
          data[x].children.push(d);
        }
        break;
        depth--;
      }

      x--;
    }
  }
}

function store_originals(data) {
  for(var i=0; i < data.length; i++) {
    var d = data[i];
    d.oWidth = d.oWidth || d.width;
    d.oX = d.oX || d.x;
    d.oY = d.oY || d.y;
  }
}


function setMaxX(data) {
  maxX = -1;

  for(var i=0; i < data.length; i++) {
    var d = data[i];
    maxX = Math.max(maxX, d.x + d.width);
  }

  xScale = d3.scale.linear()
    .domain([0, maxX])
    .range([0, width]);

  return maxX;
}

function setMaxY(data) {
  maxY = -1;
  minY = Infinity;

  for(var i=0; i < data.length; i++) {
    var d = data[i];
    if (xScale(d.width) > display_width)  {
      maxY = Math.max(maxY, d.y);
      minY = Math.min(minY, d.y);
    }
  }

  yScale = d3.scale.linear()
    .domain([0, maxY - minY + 1])
    .range([0,height]);

  return maxY;
}

function process_frame_info(data) {
  for(var i=0; i < data.length; i++) {
    var d = data[i];

    var info_frame = info[d.frame];
    if(!info_frame) {
      info[d.frame] = info_frame = {nodes: [], samples: new Set(), color: color()};
    }
    for(var j=0; j < d.width; j++){
      info_frame.samples.add(d.x + j);
    }
  }
}

function process_data(data) {

  setMaxX(data);
  setMaxY(data);

  for(var i=0; i < data.length; i++) {
    var d = data[i];

    d.scaledX = xScale(d.x-1);
    d.scaledY = yScale(maxY - d.y);
    d.displayW = d.scaledW = xScale(d.width);
    d.scaledH = yScale(1);

    var info_frame = info[d.frame];
    d.fill = info_frame.color;

  }
}

function reset_filter() {
  for(var i = 0; i < data.length; i++) {
    var d = data[i];
    d.filtered_out = null;
    d.filteredY = null;
  }
};

function filter_data_by_frame(matches) {
  if (matches.length == 0) {
    return;
  }

  var frames = [];
  for(var i=0; i < data.length; i++) {
    var d = data[i];

    if (matches.some(function(v) { return d.frame.indexOf(v) >= 0; })) {
      frames.push(d);
    } else {
      d.filtered_out = true;
      d.width = 0;
      d.x = 0;
      d.y = 0;
    }
  }

  var fix_drop = function(d, by) {
    for(var i=0; i < data.length; i++) {
      var f = data[i];
      if (
        f.oY > d.oY &&
        f.oX >= d.oX && f.oX + f.oWidth <= d.oX + d.oWidth
        ){
        f.y = f.y - by;
        f.filteredY = f.y;
      }
    }
  };

  for(var i= frames.length - 1; i > 0; i--) {
    var f = frames[i];
    var current_parent = f.parent;

    drop = 0;
    while (current_parent && current_parent.y <= 0) {
      drop = drop + 1;
      current_parent = current_parent.parent;
    }

    f.y = f.y - drop;
    f.filteredY = f.y;
    if (drop > 0) {
      fix_drop(f, drop)
    }
  }

}

function draw_data(data, options) {
  options = options || {};

  // var filtered_data = data.filter(function(d) { return d.displayW > display_width;});

  var rects = svg.selectAll("rect")
    .data(data);

  if (options.enter) {
    rects.enter()
      .append("rect")
      .each(function(d) { 
        d.node = this;
        info[d.frame].nodes.push(this);
      })
      .on("contextmenu", backtrace_data)
      .on("click", zoom)
      .on("mouseover", mouseover)
      .on("mouseout", mouseout);
  }

  rects
    .filter(function(d) { return d.displayW > display_width; })
    .transition()
    .attr("x",function(d) { return d.scaledX; })
    .attr("y",function(d) { return d.scaledY; })
    .attr("width", function(d){ return d.displayW; })
    .attr("height", function(d){ return d.scaledH; })
    .attr("fill", function(d){
      return d.fill;
    })
    .attr("opacity", function(d){ return d.opacityFactor; })
    .attr("cursor", "pointer");

  rects
    .filter(function(d) { return d.displayW < display_width; })
    .attr("width", 0);
}

function render_legend() {
  // render the legend
  $('.legend').html("");
  _.each(gemsSorted.filter(function(gem) {return (gem.samples.size / oMaxX) * 100 > 1; }), function(gem){
    var node = $("<div></div>")
      .css("background-color", gem.color)
      .text(gem.name + " " + samplePercent(gem.samples.size))
    .on("mouseover", {name: gem.name}, gemSelect)
      .on("mouseout", {name: gem.name}, gemDeSelect);
    $('.legend').append(node);
  });
}

var display_width = parseFloat($("#display_width").val());
var filters = $("#filter_string").val().split(",");
var current_zoom = null;

store_originals(data);
set_relations(data);
process_frame_info(data);
filter_data_by_frame(filters);

analyze_data(data);
process_data(data);
draw_data(data, {enter: true});

$("button[data-action=reset_zoom]").on("click", function() {
  reset_zoom();
  return false;
});

$("button[data-action=update]").on("click", function() {
  display_width = parseFloat($("#display_width").val());
  filters = $("#filter_string").val().split(",");
  by_method = $('input[name=by_method]:checked').val() == "true";

  reset_filter();
  reset_data();
  filter_data_by_frame(filters);
  analyze_data(data);
  if (current_zoom) {
    zoom(current_zoom);
  } else {
    process_data(data);
    draw_data(data);
  }
  // render_legend();

  return false;
});
  </script>
</body>
</html>
